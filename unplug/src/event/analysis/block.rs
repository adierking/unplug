use super::value::{DefId, Label, Value, ValueKind};
use crate::event::BlockId;
use arrayvec::ArrayVec;
use std::collections::HashSet;
use std::ops::{Index, IndexMut};

/// Information about a block in a script.
#[derive(Debug, Clone)]
pub struct BlockInfo {
    /// The ID of the corresponding block.
    pub id: BlockId,
    /// The IDs of blocks that can execute immediately before this block.
    pub predecessors: Vec<BlockId>,
    /// The IDs of blocks that can execute immediately after this block.
    pub successors: ArrayVec<BlockId, 2>,
    /// The definitions which are reachable at the start of this block.
    /// Computed as the union of the predecessors' outputs.
    pub inputs: HashSet<DefId>,
    /// The definitions which are reachable at the end of this block.
    /// Computed as `outputs = (inputs - kill) + generated`
    pub outputs: HashSet<DefId>,
    /// The definitions which are generated by this block.
    pub generated: HashSet<DefId>,
    /// The labels which are killed by this block - i.e. assigned to another value.
    pub killed: HashSet<Label>,
    /// The labels which are referenced by this block or a successor which could not be resolved to a
    /// value at analysis time. This is used to compute subroutine inputs.
    pub undefined: HashSet<Label>,
    /// Values accessed by the block along with their guessed types.
    pub references: Vec<(ValueKind, Value)>,
}

#[derive(Clone)]
pub(super) struct BlockInfoMap {
    blocks: Vec<Option<BlockInfo>>,
}

/// Maps Block IDs to `BlockInfo` structs.
impl BlockInfoMap {
    /// Constructs an empty `BlockInfoMap`.
    pub(super) fn new() -> Self {
        Self { blocks: vec![] }
    }

    /// Expands the size of the map if necessary.
    pub(super) fn expand(&mut self, new_size: usize) {
        if new_size > self.blocks.len() {
            self.blocks.resize(new_size, None);
        }
    }

    /// Gets a block from the map, or `None` if there is no info defined for it.
    pub(super) fn get(&self, id: BlockId) -> Option<&BlockInfo> {
        if id.index() < self.blocks.len() {
            id.get(&self.blocks).as_ref()
        } else {
            None
        }
    }

    /// Inserts a block into the map.
    pub(super) fn insert(&mut self, info: BlockInfo) {
        info.id.get_mut(&mut self.blocks).replace(info);
    }
}

impl Index<BlockId> for BlockInfoMap {
    type Output = BlockInfo;

    fn index(&self, index: BlockId) -> &Self::Output {
        index.get(&self.blocks).as_ref().unwrap()
    }
}

impl IndexMut<BlockId> for BlockInfoMap {
    fn index_mut(&mut self, index: BlockId) -> &mut Self::Output {
        index.get_mut(&mut self.blocks).as_mut().unwrap()
    }
}
